#  1.	Longest Substring Without Repeating Characters (3)

 public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> h = new HashMap<>();
        int left = 0;
        int max = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            if (h.containsKey(c) && h.get(c) >= left) {
                left = h.get(c) + 1; 
            }

            h.put(c, right); 
            max = Math.max(max, right - left + 1);
        }

        return max;
    }

# Permutation in String 

BRUTEFORCE   
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        char[] c = s1.toCharArray();
        Arrays.sort(c);
        String l = new String(c);
        int k = s1.length();
        for(int i=0;i<=s2.length()-k;i++){
            StringBuilder sb = new StringBuilder();
            for(int j=i;j<i+k;j++){
                sb.append(s2.charAt(j));
            }
            String s3 = sb.toString();
            char[] m = s3.toCharArray();
            Arrays.sort(m);
            String n = new String(m);
            if(l.equals(n)){
                return true;
            }
        }
        return false;
    }
}
OPTIMIZATION  

class Solution {
     public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;

        int[] freq1 = new int[26];
        int[] freq2 = new int[26];
        for (char c : s1.toCharArray()) {
            freq1[c - 'a']++;
        }
        int k = s1.length();
        for (int i = 0; i < k; i++) {
            freq2[s2.charAt(i) - 'a']++;
        }

        if (matches(freq1, freq2)) return true;
        for (int i = k; i < s2.length(); i++) {
            freq2[s2.charAt(i) - 'a']++;                   
            freq2[s2.charAt(i - k) - 'a']--;               

            if (matches(freq1, freq2)) return true;
        }

        return false;
    }

    private boolean matches(int[] a, int[] b) {
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}


# 3.	Find All Anagrams in a String (438)

BRUTEFORCE

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> ans = new ArrayList<>();
        int[] freq1 = new int[26];
        int[] freq2 = new int[26];

        for (char c : p.toCharArray()) {
            freq1[c - 'a']++;
        }

        int k = p.length();
        if (s.length() < k) return ans; // edge case

        for (int i = 0; i < k; i++) {
            freq2[s.charAt(i) - 'a']++;
        }

        if (matches(freq1, freq2)) ans.add(0);

        for (int i = k; i < s.length(); i++) {
            freq2[s.charAt(i) - 'a']++;
            freq2[s.charAt(i - k) - 'a']--;

            if (matches(freq1, freq2)) ans.add(i - k + 1);
        }

        return ans;
    }

    private boolean matches(int[] a, int[] b) {
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}

OPTIMISATION

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();
        if (s.length() < p.length()) return ans;

        int[] freq1 = new int[26]; // frequency of p
        int[] freq2 = new int[26]; // frequency of current window

        for (char c : p.toCharArray()) freq1[c - 'a']++;

        int k = p.length();
        for (int i = 0; i < k; i++) freq2[s.charAt(i) - 'a']++;

        int matches = 0;
        for (int i = 0; i < 26; i++) {
            if (freq1[i] == freq2[i]) matches++;
        }

        if (matches == 26) ans.add(0);

        for (int i = k; i < s.length(); i++) {
            int inChar = s.charAt(i) - 'a';
            int outChar = s.charAt(i - k) - 'a';

            // incoming char
            freq2[inChar]++;
            if (freq2[inChar] == freq1[inChar]) {
                matches++;
            } else if (freq2[inChar] == freq1[inChar] + 1) {
                matches--;
            }

            // outgoing char
            freq2[outChar]--;
            if (freq2[outChar] == freq1[outChar]) {
                matches++;
            } else if (freq2[outChar] == freq1[outChar] - 1) {
                matches--;
            }

            if (matches == 26) ans.add(i - k + 1);
        }

        return ans;
    }
}

# 4 . Longest Repeating Character Replacement

class Solution {
    public int characterReplacement(String s, int k) {
      int[] freq = new int[26];
        int left = 0, maxCount = 0, maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            freq[c - 'A']++;
            maxCount = Math.max(maxCount, freq[c - 'A']);

            // Check if window is valid
            while ((right - left + 1) - maxCount > k) {
                freq[s.charAt(left) - 'A']--;
                left++;
            }

            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;  
    }
}

# 5.	Max Consecutive Ones III (1004)

class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0, zeros = 0, maxLen = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) zeros++;

            while (zeros > k) {
                if (nums[left] == 0) zeros--;
                left++;
            }

            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}










